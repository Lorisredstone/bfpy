# code original de https://github.com/paulkaefer/bftoc

# ptr += 1;
# *ptr = 108;
# EST EQUIVALENT A
# *(++ptr) = 108;

# ptr += 2;
# *ptr = 108;
# EST EQUIVALENT A
# *(ptr += 2) = 108;

from sys import argv
from datetime import datetime

script, bf_file = argv

temp = argv[1].split(".bf")

with open(bf_file, 'r') as raw_bf_file:
    raw_bf_string  = raw_bf_file.read()

bf_string = open(bf_file, 'r').read()

commands = ",.+-[]><"

size = 30000

bf_string = ''.join(filter(lambda x: x in ['.', ',', '[', ']', '<', '>', '+', '-'], list(bf_string)))

bf_string = bf_string.replace("[-]", "a")

def get_str(char, plus_total, moins_total, droite_total, gauche_total):
    match char:
        case "+":
            return (I.PLUS, plus_total, )
        case ",":
            return (I.INPUT, )
        case "-":
            return (I.MOINS, moins_total, )
        case ".":
            return (I.PRINT, )
        case "<":
            return (I.GAUCHE, gauche_total, )
        case ">":
            return (I.DROITE, droite_total, )
        case "[":
            return (I.LOOP_OPEN, )
        case "]":
            return (I.LOOP_CLOSE, )
        case "a":
            return (I.RESET, )
    return ""

from enum import Enum, IntEnum, auto
class I(IntEnum):
    PLUS = auto()
    MOINS = auto()
    DROITE = auto()
    GAUCHE = auto()
    PRINT = auto()
    INPUT = auto()
    LOOP_OPEN = auto()
    LOOP_CLOSE = auto()
    RESET = auto()
    SET = auto()
    
instructions = []
plus_total = 1
moins_total = 1
droite_total = 1
gauche_total = 1
for i in range(len(bf_string)):
    char = bf_string[i]
    try:
        next_char = bf_string[i+1]
    except IndexError:
        next_char = None
    if next_char == char == "+": plus_total += 1
    elif next_char == char == "-": moins_total += 1
    elif next_char == char == ">": droite_total += 1
    elif next_char == char == "<": gauche_total += 1
    else:
        instructions.append(get_str(char, plus_total, moins_total, droite_total, gauche_total))
        plus_total = 1
        moins_total = 1
        droite_total = 1
        gauche_total = 1
        
# post traitement
instructions_2 = []
i = 0
while i < len(instructions):
    i1 = instructions[i]
    try:
        i2 = instructions[i+1]
    except IndexError:
        i2 = None
    if i1 == (I.RESET, ) and i2[0] == I.PLUS:
        instructions_2.append((I.SET, i2[1], ))
        i += 1
    else:
        instructions_2.append(instructions[i])
    i += 1
        
instructions = instructions_2
        

c_file = open(f'{temp[0]}.c', 'w')
c_file.write(f"/* This is a translation of {bf_file}, generated by Lorisredstone\n")
c_file.write(f" * It was generated on {datetime.now().strftime('%A, %B %d, %Y at %I:%M%p')}" + "\n")
c_file.write(" */\n\n")
c_file.write("#include <stdio.h>\n\n")
c_file.write("void main(void)\n")
c_file.write("{\n")
c_file.write("    char array[30000] = {0};\n")
c_file.write("    char *ptr = array;\n")

for x in instructions:
    match x:
        case I.PLUS, number, :
            c_file.write(f"    *ptr += {number};\n")
        case I.MOINS, number, :
            c_file.write(f"    *ptr -= {number};\n")
        case I.DROITE, number, :
            c_file.write(f"    ptr += {number};\n")
        case I.GAUCHE, number, :
            c_file.write(f"    ptr -= {number};\n")
        case I.PRINT, :
            c_file.write("    putchar(*ptr);\n")
        case I.INPUT, :
            c_file.write("    *ptr = getchar();\n")
        case I.LOOP_OPEN, :
            c_file.write("    while (*ptr) {\n")
        case I.LOOP_CLOSE, :
            c_file.write("    }\n")
        case I.RESET, :
            c_file.write("    *ptr = 0;\n")
        case I.SET, number, :
            c_file.write(f"    *ptr = {number};\n")
            
c_file.write("\n}\n\n")
c_file.close()


